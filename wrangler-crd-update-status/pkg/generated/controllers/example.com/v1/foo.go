// Code generated by main. DO NOT EDIT.

package v1

import (
	"context"
	"sync"
	"time"

	"github.com/rancher/wrangler/v3/pkg/apply"
	"github.com/rancher/wrangler/v3/pkg/condition"
	"github.com/rancher/wrangler/v3/pkg/generic"
	"github.com/rancher/wrangler/v3/pkg/kv"
	v1 "github.com/tomleb/lasso-controller-notes/pkg/apis/example.com/v1"
	"k8s.io/apimachinery/pkg/api/equality"
	"k8s.io/apimachinery/pkg/api/errors"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
)

// FooController interface for managing Foo resources.
type FooController interface {
	generic.ControllerInterface[*v1.Foo, *v1.FooList]
}

// FooClient interface for managing Foo resources in Kubernetes.
type FooClient interface {
	generic.ClientInterface[*v1.Foo, *v1.FooList]
}

// FooCache interface for retrieving Foo resources in memory.
type FooCache interface {
	generic.CacheInterface[*v1.Foo]
}

// FooStatusHandler is executed for every added or modified Foo. Should return the new status to be updated
type FooStatusHandler func(obj *v1.Foo, status v1.FooStatus) (v1.FooStatus, error)

// FooGeneratingHandler is the top-level handler that is executed for every Foo event. It extends FooStatusHandler by a returning a slice of child objects to be passed to apply.Apply
type FooGeneratingHandler func(obj *v1.Foo, status v1.FooStatus) ([]runtime.Object, v1.FooStatus, error)

// RegisterFooStatusHandler configures a FooController to execute a FooStatusHandler for every events observed.
// If a non-empty condition is provided, it will be updated in the status conditions for every handler execution
func RegisterFooStatusHandler(ctx context.Context, controller FooController, condition condition.Cond, name string, handler FooStatusHandler) {
	statusHandler := &fooStatusHandler{
		client:    controller,
		condition: condition,
		handler:   handler,
	}
	controller.AddGenericHandler(ctx, name, generic.FromObjectHandlerToHandler(statusHandler.sync))
}

// RegisterFooGeneratingHandler configures a FooController to execute a FooGeneratingHandler for every events observed, passing the returned objects to the provided apply.Apply.
// If a non-empty condition is provided, it will be updated in the status conditions for every handler execution
func RegisterFooGeneratingHandler(ctx context.Context, controller FooController, apply apply.Apply,
	condition condition.Cond, name string, handler FooGeneratingHandler, opts *generic.GeneratingHandlerOptions) {
	statusHandler := &fooGeneratingHandler{
		FooGeneratingHandler: handler,
		apply:                apply,
		name:                 name,
		gvk:                  controller.GroupVersionKind(),
	}
	if opts != nil {
		statusHandler.opts = *opts
	}
	controller.OnChange(ctx, name, statusHandler.Remove)
	RegisterFooStatusHandler(ctx, controller, condition, name, statusHandler.Handle)
}

type fooStatusHandler struct {
	client    FooClient
	condition condition.Cond
	handler   FooStatusHandler
}

// sync is executed on every resource addition or modification. Executes the configured handlers and sends the updated status to the Kubernetes API
func (a *fooStatusHandler) sync(key string, obj *v1.Foo) (*v1.Foo, error) {
	if obj == nil {
		return obj, nil
	}

	origStatus := obj.Status.DeepCopy()
	obj = obj.DeepCopy()
	newStatus, err := a.handler(obj, obj.Status)
	if err != nil {
		// Revert to old status on error
		newStatus = *origStatus.DeepCopy()
	}

	if a.condition != "" {
		if errors.IsConflict(err) {
			a.condition.SetError(&newStatus, "", nil)
		} else {
			a.condition.SetError(&newStatus, "", err)
		}
	}
	if !equality.Semantic.DeepEqual(origStatus, &newStatus) {
		if a.condition != "" {
			// Since status has changed, update the lastUpdatedTime
			a.condition.LastUpdated(&newStatus, time.Now().UTC().Format(time.RFC3339))
		}

		var newErr error
		obj.Status = newStatus
		newObj, newErr := a.client.UpdateStatus(obj)
		if err == nil {
			err = newErr
		}
		if newErr == nil {
			obj = newObj
		}
	}
	return obj, err
}

type fooGeneratingHandler struct {
	FooGeneratingHandler
	apply apply.Apply
	opts  generic.GeneratingHandlerOptions
	gvk   schema.GroupVersionKind
	name  string
	seen  sync.Map
}

// Remove handles the observed deletion of a resource, cascade deleting every associated resource previously applied
func (a *fooGeneratingHandler) Remove(key string, obj *v1.Foo) (*v1.Foo, error) {
	if obj != nil {
		return obj, nil
	}

	obj = &v1.Foo{}
	obj.Namespace, obj.Name = kv.RSplit(key, "/")
	obj.SetGroupVersionKind(a.gvk)

	if a.opts.UniqueApplyForResourceVersion {
		a.seen.Delete(key)
	}

	return nil, generic.ConfigureApplyForObject(a.apply, obj, &a.opts).
		WithOwner(obj).
		WithSetID(a.name).
		ApplyObjects()
}

// Handle executes the configured FooGeneratingHandler and pass the resulting objects to apply.Apply, finally returning the new status of the resource
func (a *fooGeneratingHandler) Handle(obj *v1.Foo, status v1.FooStatus) (v1.FooStatus, error) {
	if !obj.DeletionTimestamp.IsZero() {
		return status, nil
	}

	objs, newStatus, err := a.FooGeneratingHandler(obj, status)
	if err != nil {
		return newStatus, err
	}
	if !a.isNewResourceVersion(obj) {
		return newStatus, nil
	}

	err = generic.ConfigureApplyForObject(a.apply, obj, &a.opts).
		WithOwner(obj).
		WithSetID(a.name).
		ApplyObjects(objs...)
	if err != nil {
		return newStatus, err
	}
	a.storeResourceVersion(obj)
	return newStatus, nil
}

// isNewResourceVersion detects if a specific resource version was already successfully processed.
// Only used if UniqueApplyForResourceVersion is set in generic.GeneratingHandlerOptions
func (a *fooGeneratingHandler) isNewResourceVersion(obj *v1.Foo) bool {
	if !a.opts.UniqueApplyForResourceVersion {
		return true
	}

	// Apply once per resource version
	key := obj.Namespace + "/" + obj.Name
	previous, ok := a.seen.Load(key)
	return !ok || previous != obj.ResourceVersion
}

// storeResourceVersion keeps track of the latest resource version of an object for which Apply was executed
// Only used if UniqueApplyForResourceVersion is set in generic.GeneratingHandlerOptions
func (a *fooGeneratingHandler) storeResourceVersion(obj *v1.Foo) {
	if !a.opts.UniqueApplyForResourceVersion {
		return
	}

	key := obj.Namespace + "/" + obj.Name
	a.seen.Store(key, obj.ResourceVersion)
}
